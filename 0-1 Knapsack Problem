*/   You are given weights and values of N items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack. Note that we have only one quantity of each item.
In other words, given two integer arrays val[0..N-1] and wt[0..N-1] which represent values and weights associated with N items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You cannot break an item, either pick the complete item or donâ€™t pick it (0-1 property).

Example 1:

Input:
N = 3
W = 4
values[] = {1,2,3}
weight[] = {4,5,1}
Output: 3
Example 2:

Input:
N = 3
W = 3
values[] = {1,2,3}
weight[] = {4,5,6}
Output: 0
Your Task:
Complete the function knapSack() which takes maximum capacity W, weight array wt[], value array val[], and the number of items n as a parameter and returns the maximum possible value you can get.

// { Driver Code Starts
import java.util.*;
import java.io.*;
import java.lang.*;

class gfg
{
    public static void main(String args[])throws IOException
    {
        //reading input using BufferedReader class
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
        
        //reading total testcases
        int t = Integer.parseInt(read.readLine());
        
        while(t-- > 0)
        {
            //reading number of elements and weight
            int n = Integer.parseInt(read.readLine());
            int w = Integer.parseInt(read.readLine());
            
            int val[] = new int[n];
            int wt[] = new int[n];
            
            String st[] = read.readLine().trim().split("\\s+");
            
            //inserting the values
            for(int i = 0; i < n; i++)
              val[i] = Integer.parseInt(st[i]);
             
            String s[] = read.readLine().trim().split("\\s+"); 
            
            //inserting the weigths
            for(int i = 0; i < n; i++)
              wt[i] = Integer.parseInt(s[i]);
              
            //calling method knapSack() of class Knapsack
            System.out.println(new Solution().knapSack(w, wt, val, n));
        }
    }
}



// } Driver Code Ends




Top-Dpwn Approach(Memoization):---


class Solution 
{ 
    //Function to return max value that can be put in knapsack of capacity W.
    
    static int knapSack(int W, int wt[], int val[], int n,int [][]t) 
    { 
         // your code here 
         
         
         if(n==0 || W==0)
	     return 0;
	     
         if(t[n][W]!=-1)
	     return t[n][W];
	     
	     if(wt[n-1] > W)
	     return  t[n][W]= knapSack(W,wt,val,n-1,t);
	     
         else
	     return t[n][W]=Math.max(val[n-1]+knapSack(W-wt[n-1],wt,val,n-1,t),knapSack(W,wt,val,n-1,t));
	     
         
	     
}
     static int knapSack(int W, int wt[], int val[], int n) 
    { 
        int[][] t = new int[n+1][W+1];
        for(int i = 0; i < n + 1  ; i++)   
        for(int j = 0; j < W + 1; j++)   
            t[i][j] = -1;  
    
        return knapSack(W, wt, val, n,t );
    } 



}





Bottom-up Approach(Tabulation):---

class Solution 
{ 
    //Function to return max value that can be put in knapsack of capacity W.
    static int knapSack(int W, int wt[], int val[], int n) 
    { 
         // your code here 
         int[][] t = new int[n+1][W+1];
         for(int i = 0; i < n + 1; i++){
         for(int j = 0; j < W + 1; j++) {
           if(i==0 || j==0)
            t[i][j] = 0; 
         }
         }
         
         for(int i = 1; i < n + 1; i++){
         for(int j = 1; j < W + 1; j++) {
             
	     if(wt[i-1] <= j)
	     t[i][j]=Math.max(val[i-1]+ t[i-1][j-wt[i-1]],t[i-1][j]);
	     
         else
	     t[i][j]= t[i-1][j];
         }
         }
         
         return t[n][W];
    } 
}
